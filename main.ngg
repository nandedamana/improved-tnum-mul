// Nandakumar Edamana
// Started 2025-08-09

vh #include <omp.h>

vh #include "lib.h"

refer math
refer './nggvector.ngg'

vh typedef struct tnum tnum;

shadow of tnum struct tnum
	value u64; mask u64;;
shadow fun TNUM gives tnum takes v, m u64;
shadow fun tnum_mul gives tnum takes a, b tnum;
shadow fun tnum_union gives tnum takes a, b tnum;
shadow fun my_tnum_mul gives tnum takes a, b tnum;
shadow fun my_tnum_mul_commutative gives tnum takes a, b tnum;
shadow fun wellformed gives bool takes x tnum;
shadow fun ingamma gives bool takes x u64, T tnum;
shadow fun print_tnum takes lbl string, x tnum;
shadow fun tnums_differ gives bool takes t1, t2 tnum;

// Careful when increasing this; ASSERT1 could fail; read the related comment.
var MAX_U64 u64 / 16

fun getalpha gives tnum takes xs u64vector
	assert gt =get-count\xs 0

	// Can't start with =TNUM/[0, 0] as it may not be part of xs
	var T / =TNUM/[..0\xs, 0]

	for i from 1 under =get-count\xs
		==T =tnum_union/[T, =TNUM/[..i\xs, 0]]
	;

	return T
;

// Can't name "gamma" because that's in libm
fun getgamma gives u64vector takes T tnum
	local vec new u64vector

	for x from 0u upto (bito mask\T value\T) // max is mask|value
		if =ingamma/[x, T]
			=append\vec/[x];;
	;

	return steal vec
;

fun append-nondup takes vec u64vector, x u64
	// Can't assume vec is sorted
	for y in vec
		if eq y x
			return;;;

	=append\vec/[x]
;

fun mulvec gives u64vector takes avec, bvec u64vector
	local vec new u64vector; // TODO use set instead

	for a in avec
		for b in bvec
			// Yes, duplicates are expected when multiplying gamma(P) with gamma(Q)
			=append-nondup/[vec, mul a b];;;

	return steal vec
;

fun left_subset_of_right gives bool takes l, r u64vector
	for li in l
		var found / false

		for ri in r
			if eq li ri
				==found true
				break
			;
		;

		if not found
			return false;;
	;

	return true
;

fun printvec takes lbl string, vec u64vector
	=printf/["%s = { ", lbl]

	for x in vec
		=printf/["%zu, ", x];;

	=puts/[" }"]
;

enum MineVsKernel
	MINE_BETTER, SAME, MINE_WORSE
;

// Returns myprod optimal, linprod optimal, precision comparison
fun isoptimal gives (bool, bool, MineVsKernel) takes P, Q tnum, commutative, print-each, print-sets bool
	var linprod / =tnum_mul/[P, Q]
	var myprod / xif commutative then =my_tnum_mul_commutative/[P, Q] else =my_tnum_mul/[P, Q]

	local gamma_linprod / =getgamma/[linprod]
	local gamma_myprod / =getgamma/[myprod]
	local gamma_P / =getgamma/[P]
	local gamma_Q / =getgamma/[Q]
	local exactprods / =mulvec/[gamma_P, gamma_Q]
	var optprod / =getalpha/[exactprods]

	// Just for sanity check
	local gamma_optprod / =getgamma/[optprod]

	if print-each
		=print_tnum/["P", P]
		=print_tnum/["Q", Q]
		=print_tnum/["linprod", linprod]
		=print_tnum/["myprod", myprod]
		=print_tnum/["optprod", optprod]

		=printf/['count(gamma_linprod) = %d\n', =get-count\gamma_linprod]
		=printf/['count(gamma_myprod) = %d\n', =get-count\gamma_myprod]
		=printf/['count(gamma_P) = %d\n', =get-count\gamma_P]
		=printf/['count(gamma_Q) = %d\n', =get-count\gamma_Q]
		=printf/['count(exactprods) = %d\n', =get-count\exactprods]
		=printf/['count(gamma_optprod) = %d\n', =get-count\gamma_optprod]

		if print-sets
			=printvec/["gamma_linprod", gamma_linprod]
			=printvec/["gamma_myprod", gamma_myprod]
			=printvec/["gamma_P", gamma_P]
			=printvec/["gamma_Q", gamma_Q]
			=printvec/["exactprods", exactprods]
			=printvec/["gamma_optprod", gamma_optprod]
		;
	;

	// count(gamma_myprod) < count(exactprods) means my_tnum_mul() is unsound.
	// NOTE: ASSERT1: This could fail even if my_tnum_mul() is sound if MAX_U64
	// is too high to the point that the truncation due to gamma(abstract_prod)
	// results in a smaller set.
	assert not lt =get-count\gamma_myprod =get-count\exactprods

	// If fails, either getalpha() or tnum_union() is incorrect
	assert le =get-count\gamma_optprod =get-count\gamma_myprod

	assert =left_subset_of_right/[exactprods, gamma_myprod]

	var optimal / not =tnums_differ/[myprod, optprod]

	var mine-vs-kernel /
		xif lt =get-count\gamma_myprod =get-count\gamma_linprod
			MINE_BETTER\MineVsKernel
		else xif eq =get-count\gamma_myprod =get-count\gamma_linprod
			SAME\MineVsKernel
		else
			MINE_WORSE\MineVsKernel

	if print-each
		=puts/[xif optimal then 'TAG: optimal' else 'TAG: suboptimal']

		switch mine-vs-kernel
		case MINE_BETTER\MineVsKernel
			=puts/['TAG: better'];;
		case SAME\MineVsKernel
			=puts/['TAG: same'];;
		case MINE_WORSE\MineVsKernel
			=puts/['TAG: worse'];;

		=putchar/[c'\n']
	;

	return optimal, not =tnums_differ/[linprod, optprod], mine-vs-kernel
;

struct CumulativeStat
	bettercount  int
	samecount    int
	worsecount   int
	optimalcount int
	optimalcount_linux int
	totalcount   int
;

fun print-cumustat takes lbl string, bits int, cumustat CumulativeStat
	=printf/['%s (bits = %d): \n', lbl, bits]
	=printf/['  better = %d\n', bettercount\cumustat]
	=printf/['  same   = %d\n', samecount\cumustat]
	=printf/['  worse  = %d\n', worsecount\cumustat]
	=printf/['  myprod optimal cases  = %d / %d\n',
	         optimalcount\cumustat, totalcount\cumustat]
	=printf/['  linprod optimal cases = %d / %d\n',
	         optimalcount_linux\cumustat, totalcount\cumustat]
;

fun $main
	var bits / 3
	var commutative, print-sets bool
	var print-each / true

	var argi / 1
	while lt argi argc
		switch ..argi\argv
		case '--commutative'
			==commutative true
		;
		case '--bits'
			sum= argi 1
			if not lt argi argc
				=fprintf/[stderr, 'error: missing argument for --bits\n']
				=exit/[EXIT_FAILURE]
			;
			==bits =atoi/[..argi\argv]
		;
		case '--no-print-each'
			==print-each false
		;
		case '--print-sets'
			==print-sets true
		;
		default
			=fprintf/[stderr, 'error: unknown command-line option: %s\n', ..argi\argv]
			=exit/[EXIT_FAILURE]
		;

		sum= argi 1
	;

	var cumustat CumulativeStat

	v omp_lock_t statlock;
	v omp_init_lock(&statlock);

	var maxnum / as uint sub =pow/[2, bits] 1
	var optimal_for_bits / true

	// Generate all possible well-formed abstract pairs (P, Q) within the range
	v #pragma omp parallel for
	for xm from 0u upto maxnum
		for xv from 0u upto maxnum
			var x / =TNUM/[xv, xm]
			if not =wellformed/[x]
				continue;;

			for ym from 0u upto maxnum
				for yv from 0u upto maxnum
					var y / =TNUM/[yv, ym]
					if not =wellformed/[y]
						continue;;

					if print-each
						=flockfile/[stdout];;

					var (optimal, linoptimal, mine-vs-kernel) /
						=isoptimal/[x, y, commutative, print-each, print-sets]

					v omp_set_lock(&statlock);

					if optimal
						sum= optimalcount\cumustat 1;;
					else
						==optimal_for_bits false;;

					if linoptimal
						sum= optimalcount_linux\cumustat 1;;

					switch mine-vs-kernel
					case MINE_BETTER\MineVsKernel
						sum= bettercount\cumustat 1;;
					case SAME\MineVsKernel
						sum= samecount\cumustat 1;;
					case MINE_WORSE\MineVsKernel
						sum= worsecount\cumustat 1;;

					sum= totalcount\cumustat 1

					if print-each
						=print-cumustat/["mine vs kernel stats so far", bits, cumustat]
						=puts/['----------------------------------------------------------']
						=funlockfile/[stdout]
					;

					v omp_unset_lock(&statlock);
				;
			;
		;
	;

	v omp_destroy_lock(&statlock);

	// This assertion helps detect race condition
	var pwr / =pow/[3, bits]
	assert eq totalcount\cumustat (mul pwr pwr)

	=print-cumustat/["mine vs kernel final stats", bits, cumustat]
	=printf/['  is optimal for %d bit(s): %d\n', bits, optimal_for_bits]

	return 0;
;
