// 2025-08-09

vh #include <stdint.h>
vh #include "lib.h"

refer math
include vector

vh typedef struct tnum tnum;

shadow of tnum struct tnum
	value u64; mask u64;;
shadow fun TNUM gives tnum takes v, m u64;
shadow fun tnum_mul gives tnum takes a, b tnum;
shadow fun wellformed gives bool takes x tnum;
shadow fun ingamma gives bool takes x u64, T tnum;
shadow fun print_tnum takes lbl string, x tnum;
shadow fun tnums_differ gives bool takes t1, t2 tnum;

// Careful when increasing this; ASSERT1 could fail; read the related comment.
var MAX_U64 u64 / 16

bake vector with u64 as u64vector

// TODO verify
fun tnum_union gives tnum takes t1, t2 tnum
	var value / bita value\t1 value\t2
	var mask / bito bito (bitx value\t1 value\t2) mask\t1 mask\t2

	return =TNUM/[bita value (bitn mask), mask]
;

fun getalpha gives tnum takes xs u64vector
	assert gt =get-count\xs 0

	// Can't start with =TNUM/[0, 0] as it may not be part of xs
	var T / =TNUM/[..0\xs, 0]

	// TODO start from 1
	for x in xs
		==T =tnum_union/[T, =TNUM/[x, 0]]
	;

	return T
;

// Can't name "gamma" because that's in libm
fun getgamma gives u64vector takes T tnum
	local vec new u64vector

	for x from 0u upto (bito mask\T value\T) // max is mask|value
		if =ingamma/[x, T]
			=append\vec/[x];;
	;

	return steal vec
;

// TODO use set instead
// Yes, duplicates are a reality when multiplying gamma(P) with gamma(Q)
fun append-nondup takes vec u64vector, x u64
	// Can't assume vec is sorted
	for y in vec
		if eq y x
			return;;;

	=append\vec/[x]
;

fun mulvec gives u64vector takes avec, bvec u64vector
	local vec new u64vector

	for a in avec
		for b in bvec
			=append-nondup/[vec, mul a b];;;

	return steal vec
;

fun printvec takes lbl string, vec u64vector
	=printf/["%s = { ", lbl]

	for x in vec
		=printf/["%zu, ", x];;

	=puts/[" }"]
;

// Returns false if suboptimal
fun isoptimal gives bool takes P, Q tnum
	var linprod tnum / =tnum_mul/[P, Q]

	local gamma_linprod / =getgamma/[linprod]
	local gamma_P / =getgamma/[P]
	local gamma_Q / =getgamma/[Q]
	local exactprods / =mulvec/[gamma_P, gamma_Q]
	var optprod / =getalpha/[exactprods]

	// Just for sanity check
	local gamma_optprod / =getgamma/[optprod]

	=print_tnum/["P", P]
	=print_tnum/["Q", Q]
	=print_tnum/["linprod", linprod]
	=print_tnum/["optprod", optprod]

	=printf/['count(gamma_linprod) = %d\n', =get-count\gamma_linprod]
	=printf/['count(gamma_P) = %d\n', =get-count\gamma_P]
	=printf/['count(gamma_Q) = %d\n', =get-count\gamma_Q]
	=printf/['count(exactprods) = %d\n', =get-count\exactprods]
	=printf/['count(gamma_optprod) = %d\n', =get-count\gamma_optprod]

	/*
	=printvec/["gamma_linprod", gamma_linprod]
	=printvec/["gamma_P", gamma_P]
	=printvec/["gamma_Q", gamma_Q]
	=printvec/["exactprods", exactprods]
	=printvec/["gamma_optprod", gamma_optprod]
	*/

	// count(gamma_linprod) < count(exactprods) means tnum_mul() is unsound.
	// NOTE: ASSERT1: This could fail even if tnum_mul() is sound if MAX_U64
	// is too high to the point that the truncation due to gamma(abstract_prod)
	// results in a smaller set.
	assert not lt =get-count\gamma_linprod =get-count\exactprods

	// If fails, either getalpha() or tnum_union() is incorrect
	assert le =get-count\gamma_optprod =get-count\gamma_linprod

	var optimal / true

	if =tnums_differ/[linprod, optprod]
		==optimal false
		=puts/['^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Suboptimal!']
	;

	=puts/['']

	return optimal
;

fun $main
	var BITS / [1, 2, 4, 8]

	// TODO tnums generated for testing n+1 bits is a superset of tnums generated
	// for n bits; memoize or skip.
	for bits in BITS
		var maxnum / as uint sub =pow/[2, bits] 1
		var optimal_for_bits / true

		// Generate all possible well-formed abstract pairs (P, Q) within the range
		for xm from 0u upto maxnum
			for xv from 0u upto maxnum
				var x / =TNUM/[xv, xm]
				if not =wellformed/[x]
					continue;;

				for ym from 0u upto maxnum
					for yv from 0u upto maxnum
						var y / =TNUM/[yv, ym]
						if not =wellformed/[y]
							continue;;

						if not =isoptimal/[x, y]
							==optimal_for_bits false;;
					;
				;
			;
		;

		=printf/['optimal for %d bit(s) = %d\n', bits, optimal_for_bits]
	;

	return 0;
;
