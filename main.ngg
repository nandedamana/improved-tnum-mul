// 2025-08-09

vh #include <stdint.h>
vh #include "lib.h"

refer math
include vector

vh typedef struct tnum tnum;

shadow of tnum struct tnum
	value u64; mask u64;;
shadow fun TNUM gives tnum takes v, m u64;
shadow fun tnum_mul gives tnum takes a, b tnum;
shadow fun my_tnum_mul gives tnum takes a, b tnum;
shadow fun wellformed gives bool takes x tnum;
shadow fun ingamma gives bool takes x u64, T tnum;
shadow fun print_tnum takes lbl string, x tnum;
shadow fun tnums_differ gives bool takes t1, t2 tnum;

// Careful when increasing this; ASSERT1 could fail; read the related comment.
var MAX_U64 u64 / 16

bake vector with u64 as u64vector

// TODO verify
fun tnum_union gives tnum takes t1, t2 tnum
	var value / bita value\t1 value\t2
	var mask / bito bito (bitx value\t1 value\t2) mask\t1 mask\t2

	return =TNUM/[bita value (bitn mask), mask]
;

fun getalpha gives tnum takes xs u64vector
	assert gt =get-count\xs 0

	// Can't start with =TNUM/[0, 0] as it may not be part of xs
	var T / =TNUM/[..0\xs, 0]

	// TODO start from 1
	for x in xs
		==T =tnum_union/[T, =TNUM/[x, 0]]
	;

	return T
;

// Can't name "gamma" because that's in libm
fun getgamma gives u64vector takes T tnum
	local vec new u64vector

	for x from 0u upto (bito mask\T value\T) // max is mask|value
		if =ingamma/[x, T]
			=append\vec/[x];;
	;

	return steal vec
;

// TODO use set instead
// Yes, duplicates are a reality when multiplying gamma(P) with gamma(Q)
fun append-nondup takes vec u64vector, x u64
	// Can't assume vec is sorted
	for y in vec
		if eq y x
			return;;;

	=append\vec/[x]
;

fun mulvec gives u64vector takes avec, bvec u64vector
	local vec new u64vector

	for a in avec
		for b in bvec
			=append-nondup/[vec, mul a b];;;

	return steal vec
;

fun left_subset_of_right gives bool takes l, r u64vector
	for li in l
		var found / false

		for ri in r
			if eq li ri
				==found true
				break
			;
		;

		if not found
			return false;;
	;

	return true
;

fun printvec takes lbl string, vec u64vector
	=printf/["%s = { ", lbl]

	for x in vec
		=printf/["%zu, ", x];;

	=puts/[" }"]
;

enum MineVsKernel
	BETTER, SAME, WORSE
;

// Returns false if suboptimal
fun isoptimal gives (bool, MineVsKernel) takes P, Q tnum
	var linprod tnum / =tnum_mul/[P, Q]
	var myprod tnum / =my_tnum_mul/[P, Q]

	local gamma_linprod / =getgamma/[linprod]
	local gamma_myprod / =getgamma/[myprod]
	local gamma_P / =getgamma/[P]
	local gamma_Q / =getgamma/[Q]
	local exactprods / =mulvec/[gamma_P, gamma_Q]
	var optprod / =getalpha/[exactprods]

	// Just for sanity check
	local gamma_optprod / =getgamma/[optprod]

	=print_tnum/["P", P]
	=print_tnum/["Q", Q]
	=print_tnum/["linprod", linprod]
	=print_tnum/["myprod", myprod]
	=print_tnum/["optprod", optprod]

	=printf/['count(gamma_linprod) = %d\n', =get-count\gamma_linprod]
	=printf/['count(gamma_myprod) = %d\n', =get-count\gamma_myprod]
	=printf/['count(gamma_P) = %d\n', =get-count\gamma_P]
	=printf/['count(gamma_Q) = %d\n', =get-count\gamma_Q]
	=printf/['count(exactprods) = %d\n', =get-count\exactprods]
	=printf/['count(gamma_optprod) = %d\n', =get-count\gamma_optprod]

	=printvec/["gamma_linprod", gamma_linprod]
	=printvec/["gamma_myprod", gamma_myprod]
	=printvec/["gamma_P", gamma_P]
	=printvec/["gamma_Q", gamma_Q]
	=printvec/["exactprods", exactprods]
	=printvec/["gamma_optprod", gamma_optprod]

	// count(gamma_myprod) < count(exactprods) means my_tnum_mul() is unsound.
	// NOTE: ASSERT1: This could fail even if my_tnum_mul() is sound if MAX_U64
	// is too high to the point that the truncation due to gamma(abstract_prod)
	// results in a smaller set.
	assert not lt =get-count\gamma_myprod =get-count\exactprods

	// If fails, either getalpha() or tnum_union() is incorrect
	assert le =get-count\gamma_optprod =get-count\gamma_myprod

	// TODO check correctness by checking elements
	assert =left_subset_of_right/[exactprods, gamma_myprod]

	var optimal / true

	if =tnums_differ/[myprod, optprod]
		==optimal false
		=puts/['^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Suboptimal!']
	;

	=puts/['']

	var mine-vs-kernel / WORSE\MineVsKernel

	if lt =get-count\gamma_myprod =get-count\gamma_linprod
		==mine-vs-kernel BETTER\MineVsKernel;;
	elif eq =get-count\gamma_myprod =get-count\gamma_linprod
		==mine-vs-kernel SAME\MineVsKernel;;

	return optimal, mine-vs-kernel
;

fun $main
	//var BITS / [1, 2, 4, 8]
	var BITS / [4]

	var bettercount, samecount, worsecount int

	// TODO tnums generated for testing n+1 bits is a superset of tnums generated
	// for n bits; memoize or skip.
	for bits in BITS
		var maxnum / as uint sub =pow/[2, bits] 1
		var optimal_for_bits / true

		// Generate all possible well-formed abstract pairs (P, Q) within the range
		v #pragma omp parallel for
		for xm from 0u upto maxnum
			for xv from 0u upto maxnum
				var x / =TNUM/[xv, xm]
				if not =wellformed/[x]
					continue;;

				for ym from 0u upto maxnum
					for yv from 0u upto maxnum
						var y / =TNUM/[yv, ym]
						if not =wellformed/[y]
							continue;;

						var (optimal, mine-vs-kernel) / =isoptimal/[x, y]
						if not optimal
							==optimal_for_bits false;;

						switch mine-vs-kernel
						case BETTER\MineVsKernel
							sum= bettercount 1;;
						case SAME\MineVsKernel
							sum= samecount 1;;
						case WORSE\MineVsKernel
							sum= worsecount 1;;
					;
				;
			;
		;

		=printf/['optimal for %d bit(s) = %d\n', bits, optimal_for_bits]
		=puts/['Mine vs kernel: ']
		=printf/['  better = %d\n', bettercount]
		=printf/['  same   = %d\n', samecount]
		=printf/['  worse  = %d\n', worsecount]
	;

	return 0;
;
