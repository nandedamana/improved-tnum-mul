// 2025-08-09

vh #include <stdint.h>
vh #include "lib.h"

refer math
include vector

vh typedef struct tnum tnum;

shadow of tnum struct tnum
	value u64; mask u64;;
shadow fun TNUM gives tnum takes v, m u64;
shadow fun tnum_mul gives tnum takes a, b tnum;
shadow fun tnum_union gives tnum takes a, b tnum;
shadow fun my_tnum_mul gives tnum takes a, b tnum;
shadow fun wellformed gives bool takes x tnum;
shadow fun ingamma gives bool takes x u64, T tnum;
shadow fun print_tnum takes lbl string, x tnum;
shadow fun tnums_differ gives bool takes t1, t2 tnum;

// Careful when increasing this; ASSERT1 could fail; read the related comment.
var MAX_U64 u64 / 16

bake vector with u64 as u64vector

fun getalpha gives tnum takes xs u64vector
	assert gt =get-count\xs 0

	// Can't start with =TNUM/[0, 0] as it may not be part of xs
	var T / =TNUM/[..0\xs, 0]

	// TODO start from 1
	for x in xs
		==T =tnum_union/[T, =TNUM/[x, 0]]
	;

	return T
;

// Can't name "gamma" because that's in libm
fun getgamma gives u64vector takes T tnum
	local vec new u64vector

	for x from 0u upto (bito mask\T value\T) // max is mask|value
		if =ingamma/[x, T]
			=append\vec/[x];;
	;

	return steal vec
;

// TODO use set instead
// Yes, duplicates are a reality when multiplying gamma(P) with gamma(Q)
fun append-nondup takes vec u64vector, x u64
	// Can't assume vec is sorted
	for y in vec
		if eq y x
			return;;;

	=append\vec/[x]
;

fun mulvec gives u64vector takes avec, bvec u64vector
	local vec new u64vector

	for a in avec
		for b in bvec
			=append-nondup/[vec, mul a b];;;

	return steal vec
;

fun left_subset_of_right gives bool takes l, r u64vector
	for li in l
		var found / false

		for ri in r
			if eq li ri
				==found true
				break
			;
		;

		if not found
			return false;;
	;

	return true
;

fun printvec takes lbl string, vec u64vector
	=printf/["%s = { ", lbl]

	for x in vec
		=printf/["%zu, ", x];;

	=puts/[" }"]
;

enum MineVsKernel
	MINE_BETTER, SAME, MINE_WORSE
;

// Returns myprod optimal, linprod optimal, precision comparison
fun isoptimal gives (bool, bool, MineVsKernel) takes P, Q tnum, print-sets bool
	var linprod tnum / =tnum_mul/[P, Q]
	var myprod tnum / =my_tnum_mul/[P, Q]

	local gamma_linprod / =getgamma/[linprod]
	local gamma_myprod / =getgamma/[myprod]
	local gamma_P / =getgamma/[P]
	local gamma_Q / =getgamma/[Q]
	local exactprods / =mulvec/[gamma_P, gamma_Q]
	var optprod / =getalpha/[exactprods]

	// Just for sanity check
	local gamma_optprod / =getgamma/[optprod]

	=print_tnum/["P", P]
	=print_tnum/["Q", Q]
	=print_tnum/["linprod", linprod]
	=print_tnum/["myprod", myprod]
	=print_tnum/["optprod", optprod]

	=printf/['count(gamma_linprod) = %d\n', =get-count\gamma_linprod]
	=printf/['count(gamma_myprod) = %d\n', =get-count\gamma_myprod]
	=printf/['count(gamma_P) = %d\n', =get-count\gamma_P]
	=printf/['count(gamma_Q) = %d\n', =get-count\gamma_Q]
	=printf/['count(exactprods) = %d\n', =get-count\exactprods]
	=printf/['count(gamma_optprod) = %d\n', =get-count\gamma_optprod]

	if print-sets
		=printvec/["gamma_linprod", gamma_linprod]
		=printvec/["gamma_myprod", gamma_myprod]
		=printvec/["gamma_P", gamma_P]
		=printvec/["gamma_Q", gamma_Q]
		=printvec/["exactprods", exactprods]
		=printvec/["gamma_optprod", gamma_optprod]
	;

	// count(gamma_myprod) < count(exactprods) means my_tnum_mul() is unsound.
	// NOTE: ASSERT1: This could fail even if my_tnum_mul() is sound if MAX_U64
	// is too high to the point that the truncation due to gamma(abstract_prod)
	// results in a smaller set.
	assert not lt =get-count\gamma_myprod =get-count\exactprods

	// If fails, either getalpha() or tnum_union() is incorrect
	assert le =get-count\gamma_optprod =get-count\gamma_myprod

	// TODO check correctness by checking elements
	assert =left_subset_of_right/[exactprods, gamma_myprod]

	var optimal / not =tnums_differ/[myprod, optprod]
	=puts/[xif optimal then 'TAG: optimal' else 'TAG: suboptimal']

	var mine-vs-kernel /
		xif lt =get-count\gamma_myprod =get-count\gamma_linprod
			MINE_BETTER\MineVsKernel
		else xif eq =get-count\gamma_myprod =get-count\gamma_linprod
			SAME\MineVsKernel
		else
			MINE_WORSE\MineVsKernel

	switch mine-vs-kernel
	case MINE_BETTER\MineVsKernel
		=puts/['TAG: better'];;
	case SAME\MineVsKernel
		=puts/['TAG: same'];;
	case MINE_WORSE\MineVsKernel
		=puts/['TAG: worse'];;

	=puts/['']

	return optimal, not =tnums_differ/[linprod, optprod], mine-vs-kernel
;

fun $main
	var bits / 3
	var print-sets / false

	var argi / 1
	while lt argi argc
		switch ..argi\argv
		case '--bits'
			sum= argi 1
			if not lt argi argc
				=fprintf/[stderr, 'error: missing argument for --bits\n']
				=exit/[EXIT_FAILURE]
			;
			==bits =atoi/[..argi\argv]
		;
		case '--print-sets'
			==print-sets true
		;
		default
			=fprintf/[stderr, 'error: unknown command-line option: %s\n', ..argi\argv]
			=exit/[EXIT_FAILURE]
		;

		sum= argi 1
	;

	var bettercount, samecount, worsecount, optimalcount, optimalcount_linux, totalcount int

	var maxnum / as uint sub =pow/[2, bits] 1
	var optimal_for_bits / true

	// Generate all possible well-formed abstract pairs (P, Q) within the range
	v #pragma omp parallel for
	for xm from 0u upto maxnum
		for xv from 0u upto maxnum
			var x / =TNUM/[xv, xm]
			if not =wellformed/[x]
				continue;;

			for ym from 0u upto maxnum
				for yv from 0u upto maxnum
					var y / =TNUM/[yv, ym]
					if not =wellformed/[y]
						continue;;

					=flockfile/[stdout]
					var (optimal, linoptimal, mine-vs-kernel) / =isoptimal/[x, y, print-sets]
					if not optimal
						==optimal_for_bits false
					;

					if optimal
						sum= optimalcount 1;;

					if linoptimal
						sum= optimalcount_linux 1;;

					switch mine-vs-kernel
					case MINE_BETTER\MineVsKernel
						sum= bettercount 1;;
					case SAME\MineVsKernel
						sum= samecount 1;;
					case MINE_WORSE\MineVsKernel
						sum= worsecount 1;;

					sum= totalcount 1

					=printf/['mine vs kernel (bits = %d): \n', bits]
					=printf/['  better = %d\n', bettercount]
					=printf/['  same   = %d\n', samecount]
					=printf/['  worse  = %d\n', worsecount]
					=printf/['  myprod optimal cases  = %d / %d\n',
					         optimalcount, totalcount]
					=printf/['  linprod optimal cases = %d / %d\n',
					         optimalcount_linux, totalcount]
					=puts/['----------------------------------------------------------']
					=funlockfile/[stdout]
				;
			;
		;
	;

	=printf/['is optimal? (bits = %d): %d\n', bits, optimal_for_bits]

	return 0;
;
